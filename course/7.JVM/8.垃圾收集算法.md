# 垃圾收集算法

![garbage-collection](https://i.loli.net/2021/05/03/x8SitcsYpLDrWU5.jpg)

通过前面的学习，我们知道了什么是垃圾，也就是知道如何去判定垃圾，判定完成之后，面临着下一个问题，如何回收这些垃圾？这就需要用到一些经典的垃圾回收算法啦！这节我们就着重来学习它！

## 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循了`分代收集(Generational Collection)`的理论进行设计，分代收集名为理论，实质是一套符合大多数运行实际情况的经验发展，它建立在三个分代假说之上：

1. **弱分代假说：** 绝大多数对象都是朝生夕灭的。
2. **强分代假说：** 熬过越多次垃圾收集过程的对象就越难以消亡。
3. **跨代引用假说：** 跨代引用相对于同代引用来说只是极少数。

这三个分代假说共同奠定了多款常用的垃圾收集器的一致设计原则：**收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(对象熬过垃圾收集器过程的次数)分配到不同的区域之中存储。**

显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把他们集中存放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的就是难以消亡的对象，那把他们集中到一起，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

把分代收集理论具体放到现在的商用Java虚拟机里面，设计者一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域。顾名思义，在新生代中，每次垃圾收集都会有大批对象死去，而每次回收之后存活的少量对象，将会逐步晋升到老年代中存放。对于那些具有跨代引用的对象，经过垃圾收集器后，依旧存活，这时，便将其在年龄增长之后晋升到老年代中，这时跨代引用随即也被消除了。

## 垃圾收集算法

### 标记清除法

![mark-clear](https://i.loli.net/2021/05/03/MVu27KnWDS3xQhO.png)

此算法与它的名字一样，分为”标记“和”清除“两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记这些存活对象，在标记完成后，统一回未被标记的对象。标记过程就是判定对象是否为垃圾的过程，这部分我们在前面已经讲过了。

之所以说它是最基础的收集算法，一方面是因为它简单，高效，另一方面是因为后续的收集算法大多都是以标记清除法为基础，对其缺点进行改进而得到的。它的缺点主要有两个：

* 执行效率不稳定：如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清楚动作，导致标记和清除这两个过程的执行效率随对象数量增长而降低。
* 内存碎片化问题：标记，清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不进行一起全量的GC。

### 标记复制算法

![mark-copy](https://i.loli.net/2021/05/03/2OQgcsTVPueNBZU.png)

为了解决标记清除法面对大量可回收对象时执行效率低的问题，标记复制算法应用而生，这种算法将内存容量分为大小相等的两块，每次只能使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次性清理掉。

如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时就不要考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。

这种算法的优缺点非常明显：

* **优点：** 复制算法只需要将存活对象的指针修改, 按顺序分配内存, 非常高效.
* **缺点：** 因为需要将内存一分为二, 所以空间上一直需要保留一般的未使用, 这样非常消耗内存.

IBM公司曾有一项专门研究对新生代”朝生夕灭“的特点做了更量化的诠释----新生代中的对象有98%是熬不过第一轮收集。因此不需要按照1:1的比例来换房新生代的内存空间。HotSpot虚拟机具体的做法是把新生代分为一块较大的`Eden`和两块较小的`Survivor`空间,他们三者之间的比例是`9:1:1`, 每次分配内存只是用`Eden`和其中一块`Survivor`空间。发生垃圾收集时，将`Eden`和`Survivor`中仍然存活的对象一次性复制到另外的一块`survivor`空间上，然后直接清理掉`Eden`和已经使用过的那块`Survivor`空间。

标记复制算法在对象存活率较高的时候就要进行较多的复制操作，效率就会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

### 标记整理算法

![mark-clean](https://i.loli.net/2021/05/03/zgWciopSvnxOfQl.png)

针对老年代对象的存亡特征，有人提出了另外一种针对性的`标记整理算法`，其中的标记过程仍然与标记清楚算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活对象想内存空间的一端移动，然后直接清理掉边界以外的内存。

标记整理法是一种移动式的回收算法，是一项优缺点并存的风险决策：

1. 移动存活对象在老年代这种存活对象较多的区域中进行，将是一种极为负重的操作。这种对象移动操作必须全程暂停用户进程才能进行。
2. 如果采用标记清楚算法而不用移动存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖于更为复杂的内存分配器和内存访问器来解决。假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。

基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更加复杂，不移动则内存分配时会更加复杂。从垃圾收集的停顿时间来看，不移动对象停顿的时间较短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。HotSpot虚拟机里面关注吞吐量的Parallel Old收集器是基于标记整理法的，而关于延迟的CMS收集器则是基于标记清除法的。

## JVM内存配置原则

虽然有了这些算法，但是算法的执行与配置息息相关，合理的配置能够提升算法的执行效率，在JVM的内存配置中，我们需要注意以下几个原则：

1. 新生代尽可能设置大一些，如果太小将会导致：
    * YGC次数更加频繁
    * 可能会到导致YGC后的对象进入老年代，如果此时老年代满了，就可能会出发FGC。
2. 对于老年代，针对响应时间优先的应用：
    * 由于老年代通常采用并发收集器，因此其大小要综合考虑并发量和并发持续时间等参数
    * 如果设置小了，可能会造成内存碎片，高回收频率会导致应用暂停。
    * 设置设置大了，会需要较长的回收时间。
3. 对于老年代，针对吞吐量优先的应用：
    * 设置较大的新生代和较小的老年代，这样可以尽可能回收大部分短期对象，减少中期对象，而老年代尽量存放长期存活对象。
4. 根据对象存活周期进行分类，对象优先在新生代分配，长时间存活的对象进入老年代。
5. 根据不同代的特点，选取合适的收集算法，少量对象存活，适合复制算法，大量对象存活，适合标记清楚或者整理算法。







