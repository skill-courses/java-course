# JVM 内存分配

![java-mermory](https://tva1.sinaimg.cn/large/008i3skNly1gpyp4e2hrlj30he0avgml.jpg)

对Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出的问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权利交给了Java虚拟机，一旦出现内存泄漏和溢出的问题，如果不了解虚拟机是怎么样使用内存的，那么排查错误，修正问题将是一个非常艰难的任务。今天我们就来简单了解一下JVM的内存分配的知识。

## 运行时数据区

![run-time-data-area](https://tva1.sinaimg.cn/large/008i3skNly1gpzt5t3563j30e809mwfd.jpg)

一个类被JVM加载进来之后，就放到了内存中，这个内存被统称为运行时数据区。这个内存被划分为若干个不同的数据区域，这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。主要包括`程序计数器`、`虚拟机栈`、`本地方法栈`、`方法区`和`堆`等五个区域，接下来我们将分别介绍这五个区域的作用。

### 程序计数器(Program Counter Register)

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方法来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为”线程私有“的内存。

所以，每个线程拥有一个程序计数器，是线程私有的，用来存储指向下一条指令的地址，所以是一块较小的内存空间，是唯一一个在JVM规范中没有规定OutOfMemoryError的内存区域；在创建线程的时候，创建相应的程序计数器。

如果一个线程执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果在执行的是本地(Native)方法,这个计数器的值则为空(Undefined)。

### Java虚拟机栈

在Java虚拟机中，每个方法被执行的时候，Java虚拟都会同步创建一个栈帧用于存储局部变量表，操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

所以，栈就是有一系列帧(Frame)组成的，是每个线程私有的。

局部变量表存放了编译期间可知的各种数据基本类型和引用类型，这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

所以，栈的优缺点相当明显：
* 优点：存取速度比堆快，仅次于寄存器。
* 缺点：存在栈中的数据大小、生存期实在编译器决定的，缺乏灵活性。

### 本地方法栈

本地方法栈与虚拟机所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地方法(Native)服务。

### Java 堆(Java Heap)

JVM规范中对Java堆的描述是：所有的对象实例以及数组都应当在堆上分配。所以，此内存区域的唯一目的是存放对象实例，Java世界里几乎所有的对象实例都在这里分配内存。对于Java应用程序来说，Java堆是虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动的时创建。

从垃圾回收的角度来看，由于现代垃圾收集器都是基于分代收集理论设计的，所以Java堆中常会出现`新生代`、`老生代`、`永久代`等名字，但这些名词仅仅是一部分垃圾收集器的共同特性或者说是设计风格而已，并非某个Java虚拟机具体实现的固有内存布局，更不是JVM规范里对Java堆的进一步细致划分。不过，无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好的回收内存，或者更快的分配内存。

![java-headp-construction](https://i.loli.net/2021/04/29/cE3JQodt4jKLawB.jpg)

相比栈来说，堆有着以下的优缺点：

* 优点：运行期自动分配内存大小，自动进行垃圾回收。
* 缺点：效率相对较慢

### 方法区（Method Area）

方法区与Java堆一样，是各线程共享的内存区域，它用于存储已被虚拟机加载的类型信息，常量、形态变量、即时编译器编译后的代码缓存等数据。虽然，JVM规范中吧方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做“非堆(Non-Heap)”，目的是与Java堆区分开来。

方法区通常与元空间联系在一起，但具体的跟JVM规范和版本有关。

#### 运行时常量池

运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法和接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

运行时常量池另一个重要的特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，运行期间也可以将新的常量放入池中。

### 栈、堆与方法区之间的关系

他们三者的关系如图所示：

![heap-method-area-relationship](https://i.loli.net/2021/04/29/PUnwQtydrveC2ZE.png)

## Java命令行参数

Java命令行参数用于配置JVM的一些参数，这些参数包括指定日志的输出信息，堆栈的大小，GC信息等。目前Java命令行参数在Java9之后会做了一次较大的更新，所以，我们就一Java9之后的参数为主。

### Trace跟踪参数

常用的Trace跟踪参数有以下几个：
* `-Xlog:gc`: 打印GC的简要信息
* `-Xlog:gc*`: 打印GC的详细信息
* `-Xlog:gc:[filename]`: 指定GC log的位置，以文件输出。
* `-Xlog:gc+heap=[debug/trace...]`: 每一次GC后，打印GC和堆的信息

### Java堆参数

* `Xms`: 初始堆的大小，默认物理内存的1/64但小于1G, 最小设置要大于1M，默认当空余堆内存大于70%时，JVM会减小heap的大小到`-Xms`指定的大小，可通过`-XX:MaxHeapFreeRation=`来指定这个比列。Server端JVM最好将`-Xms`和`-Xmx`设为相同值，避免每次垃圾回收完成后JVM重新分配内存；

* `Xms`: 最大堆大小，默认物理内存的1/4, 但小于1G, 并且要大于2M，默认当空余堆内存小于40%时，JVM会增大Heap到`-Xmx`指定的大小，可通过`-XX:MinHeapFreeRation=`来指定这个比列。最佳设值应该视物理内存大小及计算机内其他内存开销而定。通常情况下，可以设置`Xmx`与`Xmx`相等来避免每次GC之后调整对的大小而带来的性能消耗。

* `Xmn`: 新生代的大小，默认为整个堆大小的3/8, 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小, 持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的25%~50%之间。 

* `Xss`: Java每个线程的Stack大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。




