# 经典垃圾收集器

![GC-popularity](https://i.loli.net/2021/05/04/nfwEucpDx63LT4G.png)

如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的实践者。

标题中使用”经典“二字是为了与几款目前仍处于试验状态，但执行效果上面有革命性改进的高性能低延迟收集器区分开来，这些经典的收集器尽管已经算不上是最先进的技术，但他们曾在实践中千锤百炼，足够成熟，基本上可以认为是现在到未来两三年内能够在商用生产环境上放心使用的全部垃圾收集器了。

## GC性能指标

不同的收集器由于使用了不同的收集算法，所以他们的性能也不一样。衡量一款垃圾收集器是否足够优异，主要以下衡量指标：

* **吞吐量：** `应用代码执行的时间`/`运行总时间`。其中`运行总时间` = `应用代码执行的时间` + `垃圾收集执行时间`。
* **GC负荷：** 与吞吐量相反，是`GC时间`/`运行总时间`。
* **暂停时间：** 就是发生STW的总时间。  
* **GC频率：** 就是GC在一个时间段发生的次数。
* **反应速度：** 就是从对象成为垃圾到被回收的时间。
* 交互式应用通常希望暂停时间越少越好。

需要说明的是，上面的指标仅仅是一种衡量方向，并不代表每个指标越快越好，需要根据时机的应用场景来衡量。

## 几款经典分代垃圾收集器

![Classic-Garbage-Collector](https://i.loli.net/2021/05/04/lK7xbHmeMOAwvZU.png)

上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明他们之间可以搭配使用，收集器所处的区域，则表示它是属于新生代收集器还是老生代收集器。 接下来，我们将这些经典的收集器逐一介绍其目标，特性，原理和使用场景，深入了解它们的部分运作细节。

需要明白的是，虽然，我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来，虽然垃圾收集器的技术在不断的进步，但直到现在还没有最好的收集器出现，就更不用说有”万能“的收集器出现了，所以我们选择的只是针对具体应用下的最合适的收集器。

### `Serial`/`Serial Old`收集器

Serial系列收集器是最基础，历史上最悠久的收集器，曾经在JDK1.3之前是HotSpot的唯一选择。

这两个收集器是一个单线程串行收集器，也就是说，它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须要暂停其他所有工作的线程，直到它收集结束。

他们的工作原理如下：

当工作线程运行到一定的临界点之后，所有工作线程暂停，GC线程启动，新生代(Serial)采用复制算法来收集垃圾，老年代(Serial Old)采用标记整理算法进行垃圾收集，收集工作完成之后，用户线程恢复执行。

![GC-Serial](https://i.loli.net/2021/05/04/Y3bkEW1Ta4XsS86.jpg)

虽然，这两个收集器会STW，但是事实上，迄今为止，它们依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方：**简单而高效！**，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单核或者处理器核心比较少的环境来说，Serial系列收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。所以，Serial系列收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。

当然，`Serial Old`收集器有时也在服务端模式下使用，主要有两个用途：

1. 在JDK1.5之前的版本中与Parallel Scavenge收集器搭配使用。
2. 作为CMS收集器发生失败的时候的后备预案，在并发收集发生Concurrent Mode Failure时使用。

### `ParNew`收集器

此收集器实质上是`Serial`收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的收集行为包括`Serial`收集器可用的所有控制参数斗鱼`Serail`收集器完全一致，在实现上这两者也公用了相当多的代码。

工作原理如下：

![GC-ParNew](https://i.loli.net/2021/05/04/BAhz9cY2JbgsqEk.jpg)

ParNew收集器除了支持多线程收集之外，并没有其他地方比Serial收集器有太多的创举。之所以其能成为`HotSpot`官方推荐的在服务器模式下的收集器解决方案的原因很重要的是`CMS`收集器的出现，此收集器是唯一一款能与`CMS`配合使用的新生代并行收集器。

但是成也萧何败也萧何，随着垃圾收集器技术的不断改进，更先进的G1收集器带着CMS继承者和替代者的光环登场。G1是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。所以，此收集器是`HotSpot`虚拟机中第一款退出历史舞台的垃圾收集器。

ParNew收集器在单核处理器的环境中绝对不会比Serial收集器效果更好，但是随着可以被使用的处理器核心的增加，ParNew对于垃圾收集器时系统资源的高效利用还是有很多好处的，它默认开启的收集线程数和处理器的核心数量相同。

### `Parallel Scavenge`/`Parallel Old`收集器

`Parallel Scavenge`收集器是一款新生代并行多线程收集器，同样是支持标记复制算法的收集器。看起来与ParNew收集器非常相似，但是它的特别之处在于，它的设计目标则是为了达到一个可控制的吞吐量。所谓吞吐量，就是处理器用于运行晕乎代码的时间与处理器总消耗的时间的比值：`应用代码执行的时间`/`运行总时间`。

停顿时间越短越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量可以最高效率的利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析性任务。

`Parallel Old`是`Parallel Scavenge`收集器的老年代版本，同样支持多线程并行收集，基础标记整理算法实现。由于`Parallel Scavenge`无法与`CMS`搭配使用，所以`Parallel Scavenge`一直处于尴尬的状态，直到`Parallel Old`的出现后，”吞吐量优先“收集器终于有了名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑`Parallel Scavenge`+``Parallel Old`的组合。

他们的工作示意图如下：

![GC-Parallel](https://i.loli.net/2021/05/04/HqOrZYt1hWzK9Gs.png)

### CMS收集器



