# 经典垃圾收集器

![GC-popularity](https://i.loli.net/2021/05/04/nfwEucpDx63LT4G.png)

如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的实践者。

标题中使用”经典“二字是为了与几款目前仍处于试验状态，但执行效果上面有革命性改进的高性能低延迟收集器区分开来，这些经典的收集器尽管已经算不上是最先进的技术，但他们曾在实践中千锤百炼，足够成熟，基本上可以认为是现在到未来两三年内能够在商用生产环境上放心使用的全部垃圾收集器了。

## GC性能指标

不同的收集器由于使用了不同的收集算法，所以他们的性能也不一样。衡量一款垃圾收集器是否足够优异，主要以下衡量指标：

* **吞吐量：** `应用代码执行的时间`/`运行总时间`。其中`运行总时间` = `应用代码执行的时间` + `垃圾收集执行时间`。
* **GC负荷：** 与吞吐量相反，是`GC时间`/`运行总时间`。
* **暂停时间：** 就是发生STW的总时间。  
* **GC频率：** 就是GC在一个时间段发生的次数。
* **反应速度：** 就是从对象成为垃圾到被回收的时间。
* 交互式应用通常希望暂停时间越少越好。

需要说明的是，上面的指标仅仅是一种衡量方向，并不代表每个指标越快越好，需要根据时机的应用场景来衡量。

## 几款经典分代垃圾收集器

![Classic-Garbage-Collector](https://i.loli.net/2021/05/04/lK7xbHmeMOAwvZU.png)

上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明他们之间可以搭配使用，收集器所处的区域，则表示它是属于新生代收集器还是老生代收集器。 接下来，我们将这些经典的收集器逐一介绍其目标，特性，原理和使用场景，深入了解它们的部分运作细节。

需要明白的是，虽然，我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来，虽然垃圾收集器的技术在不断的进步，但直到现在还没有最好的收集器出现，就更不用说有”万能“的收集器出现了，所以我们选择的只是针对具体应用下的最合适的收集器。

### `Serial`/`Serial Old`收集器

Serial系列收集器是最基础，历史上最悠久的收集器，曾经在JDK1.3之前是HotSpot的唯一选择。

这两个收集器是一个单线程串行收集器，也就是说，它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须要暂停其他所有工作的线程，直到它收集结束。

他们的工作原理如下：

当工作线程运行到一定的临界点之后，所有工作线程暂停，GC线程启动，新生代(Serial)采用复制算法来收集垃圾，老年代(Serial Old)采用标记整理算法进行垃圾收集，收集工作完成之后，用户线程恢复执行。

![GC-Serial](https://i.loli.net/2021/05/04/Y3bkEW1Ta4XsS86.jpg)

虽然，这两个收集器会STW，但是事实上，迄今为止，它们依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方：**简单而高效！**，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单核或者处理器核心比较少的环境来说，Serial系列收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。所以，Serial系列收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。

当然，`Serial Old`收集器有时也在服务端模式下使用，主要有两个用途：

1. 在JDK1.5之前的版本中与Parallel Scavenge收集器搭配使用。
2. 作为CMS收集器发生失败的时候的后备预案，在并发收集发生Concurrent Mode Failure时使用。

### `ParNew`收集器

此收集器实质上是`Serial`收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的收集行为包括`Serial`收集器可用的所有控制参数斗鱼`Serail`收集器完全一致，在实现上这两者也公用了相当多的代码。

工作原理如下：

![GC-ParNew](https://i.loli.net/2021/05/04/BAhz9cY2JbgsqEk.jpg)

ParNew收集器除了支持多线程收集之外，并没有其他地方比Serial收集器有太多的创举。之所以其能成为`HotSpot`官方推荐的在服务器模式下的收集器解决方案的原因很重要的是`CMS`收集器的出现，此收集器是唯一一款能与`CMS`配合使用的新生代并行收集器。

但是成也萧何败也萧何，随着垃圾收集器技术的不断改进，更先进的G1收集器带着CMS继承者和替代者的光环登场。G1是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。所以，此收集器是`HotSpot`虚拟机中第一款退出历史舞台的垃圾收集器。

ParNew收集器在单核处理器的环境中绝对不会比Serial收集器效果更好，但是随着可以被使用的处理器核心的增加，ParNew对于垃圾收集器时系统资源的高效利用还是有很多好处的，它默认开启的收集线程数和处理器的核心数量相同。

### `Parallel Scavenge`/`Parallel Old`收集器

`Parallel Scavenge`收集器是一款新生代并行多线程收集器，同样是支持标记复制算法的收集器。看起来与ParNew收集器非常相似，但是它的特别之处在于，它的设计目标则是为了达到一个可控制的吞吐量。所谓吞吐量，就是处理器用于运行晕乎代码的时间与处理器总消耗的时间的比值：`应用代码执行的时间`/`运行总时间`。

停顿时间越短越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量可以最高效率的利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析性任务。

`Parallel Old`是`Parallel Scavenge`收集器的老年代版本，同样支持多线程并行收集，基础标记整理算法实现。由于`Parallel Scavenge`无法与`CMS`搭配使用，所以`Parallel Scavenge`一直处于尴尬的状态，直到`Parallel Old`的出现后，”吞吐量优先“收集器终于有了名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑`Parallel Scavenge`+``Parallel Old`的组合。

他们的工作示意图如下：

![GC-Parallel](https://i.loli.net/2021/05/04/HqOrZYt1hWzK9Gs.png)

### `CMS`收集器

`Concurrent Mark Sweep(CMS)`收集器是一款以获取最短回收停顿时间为目标的老年代并行收集器。这款收集器注重服务的响应速度，希望系统停顿的时间尽可能缩短，以给用户带来良好的交互体验。

CMS收集器是基于标记清楚算法的收集器，相对于前面的几款收集器来说，垃圾回收过程更为复杂一些，运行结构图如下：

![GC-CMS](https://i.loli.net/2021/05/04/WtZpqRoaynzMeJS.png)

CMS收集器将整个过程分为四个阶段：

1. **初始标记：** 仅仅只是标记一下GC Roots能够直接关联到的对象，速度很快，会STW。
2. **并发标记：** 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程虽然耗时较长，但是不会STW，可以与用户线程一起并发运行。
3. **重新标记：** 为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，这个计算的停顿时间会比初始阶段的停顿稍微长一些，但也远比并发标记期间的时间短。
4. **并发清除：** 清理删除掉标记阶段判断已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以和用户线程同时并发的。

由于整个收集过程中耗时最长的`并发标记`和`并发清除`阶段中垃圾收集线程可以和用户线程并行，所以总体上来说，CMS的停顿时间相对较少。CMS是一款优秀的垃圾收集器，主要的优点就在于`并发收集`和`低停顿`。

虽然优秀，但是还是无法达到完美的程度，主要有以下三个缺点：

* CMS收集器对处理器资源非常敏感。在并发收集阶段，虽然不会导致用户线程停顿，但是却会因为占用了一部分线程的计算资源而导致应用变慢，降低吞吐量。
* CMS收集器无法处理”浮动垃圾“，有可能会出现`Concurrent Mode Failure`失败进而导致一些完全的STW的FGC产生。
* 并发清楚算的收集器无法消除空间碎片过多时给大对象分配带来的麻烦。

## 新型收集器

### `Garbage First`收集器

`Garbage First(G1)`收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。JDK8以后，G1收集器被Oracle官方称为”全功能的垃圾收集器“，称为服务端模式下的默认垃圾收集器，彻底将`Parallel Scavenge`+`Parallel Old`与`ParNew`+`CMS`宣告为即将废弃的收集器。

在G1收集器出现之前的所有其他收集器，垃圾收集的目标范围要么是整个新生代，要么就是整个老年代，再要么就是整个Java堆(Full GC)。而G1跳出了这个思路的束缚，它可以面向堆内存任何部分来组成回收集合进行回收，衡量标准不再是它属于那个分代，而是那块内存存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然，G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域(Region)，每个Region都可以根据需要，扮演新生代的Eden空间、Servivor空间或者老年代空间，收集器能够对扮演不同角色的Region区域采用不同的收集策略，效果极好。

G1收集器能够建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有效的避免在整个Java堆中Full GC。更具体的思路是，让G1收集器去跟踪各个Region里面的垃圾堆积的”价值“大小，价值即回收所获得的的空间大小以及回收所需要的时间的经验值，然后在后台维护一个优先级列表，每个根据用户设置的允许的收集停顿时间有限处理回收那些价值收益最大的Region，这种收集方法保证了G1在有限的时间获取尽可能高的收集效率。

![G1-heap-allocation](https://i.loli.net/2021/05/04/BtmFkAoxhqHnTC2.png)

与CMS类似，G1将内存”化整为零“的”解题思路“主要有四个实现步骤：

1. **初始标记：** 仅仅只是标记一下GC Roots能够直接关联到的对象，速度很快，会STW。
2. **并发标记：** 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程虽然耗时较长，但是不会STW，可以与用户线程一起并发运行。
3. **最终标记：** 对用户线程做另一个短暂停顿，用于听力并发阶段结束后仍旧遗留下来的那些少量的SATB记录。
4. **筛选回收：** 负责更新Region的统计数据，对个Region的回收价值和成本进行排序，根据用户所希望的停顿时间来制定有效的回收计划，进而执行清理操作。这里的操作涉及到存活对象的移动，是必须暂停用户线程的，但是可以有多个收集器线程并行完成。

![GC-G1](https://i.loli.net/2021/05/04/cotZ7gu9QdrDnGv.png)

相比CMS收集器，G1在运作期间不会产生内存碎片，垃圾收集完成之后能够提供规整的可用内存，这种特性有利于程序长时间运行。但是，G1在运行的时候更加占用内存，所以在大内存的应用上面，G1的优势比较明显，而对于小内存的应用，CMS的表现大概率要优于G1，这个内存大小的临界值根据经验判断为`6G~8G`之间。

### `ZGC`收集器

此收集器是JDK11之后加入的具有试验性质的低延迟收集器，目前还没有普及，还在不断完善当中。其设计目标是支持TB级别的内存容量，暂停时间低与10ms，对整个程序吞吐量的影响小于15%。

此收集器里面最具代表性的新技术是`着色指针`和`读屏障`。

关于此收集器的具体信息，可以进一步关注其他文章，这里不再过多概述。



