# 类的连接与初始化

![class-connect](https://i.loli.net/2021/04/26/ZMc8tApVgs9mr6X.jpg)

通过前面的学习，我们知道类的生命周期包括`加载`、`连接`、`初始化`、`使用`和`卸载`等过程，加载的过程我们已经学习了，今天我们就来了解一下类的连接和初始化吧！

## 类的连接

类的连接主要分为三个阶段：`验证`、`准备`、`解析`, 我们来简单了解一下：

### 验证

由于我们的字节码来源多样化，并不一定来源于Class文件，所以我们需要通过一些措施来保证字节码的二进制流是正确的安全的，因此我们需要通过验证来避免虚拟机受到攻击。主要验证如下内容：

1. **类文件结构检查：** 按照JVM规范规定的类文件结构进行检查。
2. **元数据验证：** 对字节码描述的信息进行语义分析，保证其符合Java语言规范要求。
3. **字节码验证：** 通过对数据流和字节流进行分析，确保程序语义是合法和符合逻辑的，主要对方法体进行的校验。
4. **符号引用验证：** 对类自身以外的信息，也就是常量池中的各种符号引用，进行匹配校验。

### 准备

准备阶段是为类变量（static）设置内存并分配初始值的阶段，这里强调以下两点：

* 只是类变量，不包含实例变量，实例变量会在对象实例化的时候分配到堆上，但类变量（变量内存）都会在方法区（元数据）中分配内存。
* 只是分配初始值，初始值见下表，有一种情况例外，就是如果字段属性表有ConstantValue(stati final修饰的变量)属性，准备阶段就会为变量赋值而不是初始值。

|数据类型|初始值|
|:-----:|:----:|
| int | 0 |
| long | 0L |
| short | (short)0 |
| char | '\u0000' |
| byte | (byte)0 |
| boolean | false |
| float | 0.0f |
| double | 0.0d |
| reference | null |

### 解析

解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程，符号引用在Class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。

* 符号引用：以一组符号表示引用的目标，可以是任何形式的字面量，只要可以定位到目标即可。
* 直接引用：直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 

如果有了直接引用，那么引用的目标必定已经在内存中存在。

此过程主要针对的是类、接口、字段、类方法、接口方法、方法类型、方法句柄、调用限定符等。

## 类的初始化

类的初始化就是为类的静态变量赋初始值，或者说是执行类构造器<clinit>方法的过程：

1. 如果类还没有加载和连接，就先进行加载和连接。
2. 如果类存在父类，且父类没有初始化，就先初始化父类。
3. 如果类中存在初始化语句，就依次执行这些初始化语句。
4. 如果是接口的话
    * 初始化一个类的时候，并不会先初始化它实现的接口。
    * 初始化一个接口的时候，并不会初始化他的父接口。
    * 只有当程序首次使用接口里面的变量或者调用接口放的时候，才会导致接口初始化。
5. 调用ClassLoader类的loadClass方法来装载一个类，并不会初始化这个类，因为这个时候，不是对类的主动使用。

例如：

```java
public class Animal {
    static {
        System.out.println("I am a animal!");
    }
    static {
        System.out.println("I can run!");
    }
}
public class Cat extends Animal{
    static {
        System.out.println("I am a Cat!");
    }
}
public class Main {
    public static void main(String[] args) throws Exception {
        Cat cat = new Cat();
    }
}
```

输出如下结果：

```bash
I am a animal!
I can run!
I am a Cat!
```

Java程序对类的使用方式分为`主动使用`和`被动使用`, JVM必须在每个类或者接口“首次主动使用”时才初始化他们；被动的使用类不会导致类的初始化，主动使用的情况分为：

* 创建类实例。
* 访问某个类或者接口的静态变量。
* 调用类的静态方法。
* 使用Java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有经过初始化，则需要先触发其初始化。
* 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
* 当虚拟机启动的时候，用户需要指定一个需要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。
* 定义了default方法的接口，当接口实现类初始化时，虚拟机会先初始化这个接口。

## 类的卸载

类的卸载是类生命周期的最后一个阶段，当代表一个类的Class对象不会再被引用时，那么Class对象的生命周期就结束了，对应的在方法区中的数据也会被卸载。

JVM自带的类加载器加载的类，是不会被卸载的，由用户自定义的类加载器加载的类是可以卸载的。