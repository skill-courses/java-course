# 类的加载

![class_loader_in_java](https://tva1.sinaimg.cn/large/008i3skNly1gpwbp3d3h5j31do0rejuv.jpg)

我们知道，一个类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期将会经历：`加载`、`验证`、`准备`、`解析`、`初始化`、`使用`和`卸载`七个阶段, 其中验证、准备和解析三个部分称为连接。这七个阶段的发生顺序如下所示：

![class-lifecycle](https://tva1.sinaimg.cn/large/008i3skNly1gpwca8f5eaj30mg08p3z6.jpg)

* **加载：** 查找并加载类文件的二进制数据。
* **连接：** 就是将已读入内存的类的二进制数据合并到java虚拟机的运行时环境中去，主要包括三个步骤：
    * 验证：确保被加载类的正确性，主要是保证类不会危害到JVM的安全性。
    * 准备：为类的静态变量分配内存，为初始化他们做准备。
    * 解析：把常量池中的符号引用转换为直接引用。解析过后，就是让类能够直接引用到他们想要引用的类型或者目标。
* **初始化：** 为类的静态变量赋初始值。初始化包括很多情况，我们后面会详细介绍。
* **使用：** 类被初始化之后就可以被使用，使用的方式就千差万别，主要取决于业务逻辑的使用方式。
* **卸载：** 当一个类确定不会被其他引用再使用时，就将其移除内存的过程称之为卸载。

今天，我们就来学习类生命周期的第一个阶段：类的加载！

## 类加载的价值

在类加载阶段，java虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

我们通过反射来获取一个类的Class对象就是在第三步中所生成的Class对象，我们可以利用此对象来访问这个类的方法和属性等。

《Java虚拟机规范》对这三点的要求并不是特别具体，所以留给虚拟机实现与Java应用的灵活度相当大。比如第一条，它并没有指明二进制字节流必须从一个Class文件中获取，确切的说是根本没有指明是从哪里获取，如何获取等。仅仅这一点空隙，就可以指定类的不同加载方式：

1. **最常见的方式：** 从本地文件系统中加载、从jar等归档文件中加载。
2. **动态的方式：** 将java源文件动态编译成class，比如JSP应用等。
3. **其他方式：** 从网络下载，从数据库中读取，从加密文件中获取等。

相对于类加载过程的其他阶段，此阶段是开发任意可控性最强的阶段，这是因为，此阶段主要使用鼎鼎大名的类加载器完成！

## 类加载器

![classloader-category](https://tva1.sinaimg.cn/large/008i3skNly1gpwecuqlauj30le0he74v.jpg)

通常来讲，类加载器分为四种：

#### 启动类加载器(Bootstrap ClassLoader)

这个类加载器是使用C/C++语言实现的，嵌套在JVM内部，Java程序无法直接操作这个类，它用来加载Java核心类库，如`JAVA_HOME/jre/lib/rt.jar`、`resources.jar`、`sun.boot.class.path`路径下的包，用于提供jvm运行所需的包。出于安全考虑，启动类只加载包名为：java、javax、sun开头的类。需要注意的是，它并不是继承自java.lang.ClassLoader，它没有父类加载器。

#### 扩展类加载器(Extension ClassLoader)

Java语言编写，由`sun.misc.Launcher.ExtClassLoader`实现，我们可以用Java程序操作这个加载器, 派生继承自java.lang.ClassLoader，父类加载器为启动类加载器。

此类加载器主要加载两种类库：

* java.ext.dirs目录中加载类库
* 从JDK安装目录：jre/lib/ext目录下加载类库

我们就可以将我们自己的包放在以上目录下，就会自动加载进来了。

值得注意的是，此加载器在Java9以后被`平台类加载器`替代，一方面是处于安全考虑，另一方面是，Java9的模块化实现了此类加载器的功能，所以，此类加载器就没有必要进一步被使用啦。

#### 应用程序类加载器(Application Classloader)

Java语言编写，由·sun.misc.Launcher.AppClassLoader·实现。派生继承自java.lang.ClassLoader，父类加载器为启动类加载器。

它负责加载环境变量`classpath`或者系统属性`java.class.path`指定路径下的类库, 它是程序中默认的类加载器，我们Java程序中的类，都是由它加载完成的。

#### 自定义加载器

一般情况下，以上3种加载器能满足我们日常的开发工作，不满足时，我们还可以自定义加载器。接下来我们将详细研究如何自定义一个类加载器。

## 自定义类加载器

## 双亲委派模型




