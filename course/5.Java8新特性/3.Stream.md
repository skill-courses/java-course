# [Stream](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)

![java-8-stream](https://tva1.sinaimg.cn/large/008eGmZEly1govcbgj045j30p00dwjsm.jpg)

前面我们学习了文件与文件流的概念，知道流就是一种数据序列。在Java 8中，对流进行了扩展，至此流的概念不单单用于文件操作，还可以用于集合，数组等一切实现Stream接口的类或者实例。

> Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。

## 流的基本概念

前面理解的流是一种数据序列，听起来有点抽象。流不是某种元素的集合，也不是存储数的一种数据结构，它其实就是一个迭代器(流的底层实现方式就是迭代器模式)。**它是单向的、不可往复的、一旦创建就不可被修改。** 数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。

> 和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。

### 流的组成

流的组成，主要分为三个部分：**数据源（source）→ 数据转换→执行操作获取想要的结果。**

需要注意的是：每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象，这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。

![stream-compose](http://ww1.sinaimg.cn/large/af4e9f79ly1fyqw3z4g7nj20hc09oaaf.jpg)

## 流的产生

有很多方法可以创建不同源的流实例。一旦创建，实例将不会修改其源，因此允许从单个源创建多个实例。

### 1.Empty Stream

我们可以使用下面的方法来创建一个空流：

```java
Stream<String> streamEmpty = Stream.empty();
```

可能有人会问，这个方法有啥用呢？其实，主要是避免对没有元素的流返回null，例如：

```java
public Stream<String> streamOf(List<String> list) {
    return list == null || list.isEmpty() ? Stream.empty() : list.stream();
}
```

### 2.Stream of Collection

我们可以直接给实现Collection集合接口的实例(List, Set, Queue)创建流，例如：

```java
Collection<String> collection = Arrays.asList("a", "b", "c");
Stream<String> streamOfCollection = collection.stream();
```

### 3.Stream of Array

我们可以通过如下方法将数组转换为流：

```java
String[] arr = new String[]{"a", "b", "c"};
Stream<String> streamOfArray = Stream.of(arr);
Stream<String> streamOfArrayFull = Arrays.stream(arr);
Stream<String> streamOfArrayPart = Arrays.stream(arr, 1, 3);
```

### 4.Stream.builder()

When builder is used, the desired type should be additionally specified in the right part of the statement, otherwise the build() method will create an instance of the Stream<Object>:

```java
Stream<String> streamBuilder = Stream.<String>builder().add("a").add("b").add("c").build();
```

### 5.Stream.generate()

generate()方法接受Supplier<T>来生成元素。由于生成的流是无限的，开发人员应该指定所需的大小，否则generate()方法将一直工作到它达到内存限制为止.

```java
Stream<String> streamGenerated = Stream.generate(() -> "element").limit(10);
```

### 6.Stream.iterate()

Another way of creating an infinite stream is by using the iterate() method:

```java
Stream<Integer> streamIterated = Stream.iterate(40, n -> n + 2).limit(20);
```
上面的方法表示，从40开始，每次递增2，递增20次。

### 7.Stream of Primitives

