# [反射](https://www.oracle.com/technical-resources/articles/java/javareflection.html)

![java-reflection](https://tva1.sinaimg.cn/large/008eGmZEly1gp8ypefiwoj31w50u0tuj.jpg)

正常来说，我们调用一个类的方法的时候，必须通过`new`关键字生成对应的对象实例，然后调用这个对象的实例方法。这种方式是在程序运行之前就确定了要运行的类型。有种特殊的情况，就是在程序未运行之前，不知道程序中存在这样的类型，只有当程序运行起来的时候，我们再去创建对于的实例并运行特定的方法，这种方式就是我们今天要学习的`反射`。

所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法的解决方案。

>Reflection is a feature in the Java programming language. It allows an executing Java program to examine or "introspect" upon itself, and manipulate internal properties of the program

## Class类

不知道大家有没有思考过几个问题，`(类)class`是一种数据类型么？Java中是如何存储`类class`的呢？比如一个类有名称，属性和方法，那么会不会存在一种类型是如下的数据格式？

```java
public final class Class {
    private Class() {}
    private Field[] fields;
    private Method[] methods; 
}
```

你还别说，真的就存在这么一个类的类型`Class`, 来存储Java中所有的类。我们可以通过任何一个类的`.class`属性就可以获取这个对象:

```java
Class cls = String.class;
```

当然，我们还可以通过该实例变量提供的`getClass()`方法获取：

```java
String s = "Hello";
Class cls = s.getClass();
```

另外，如果知道一个class的完整类名，可以通过静态方法`Class.forName()`获取：

```java
Class cls = Class.forName("java.lang.String");
```

这会儿可能就会有人问，获取这个`Class`对象有啥用呢？这个用处可大了，获取了这个对象，就意味着我们在运行期可以对此类的方法和属性站在更高的角度随意操作，甚至在程序运行的过程中，就可以从一个配置文件中自动读取并自动生成对象到内存中来，这让我们实现动态代理成为了可能。

既然这个对象这么神奇，那么我们如何操作这个对象提供的方法和属性呢？

## 访问字段

`Class`类提供了以下几种方式来获取字段：

* Field getField(name)：根据字段名获取某个public的field（包括父类）
* Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）
* Field[] getFields()：获取所有public的field（包括父类）
* Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）

例如：
```java
public class Animal {
    public String name;
}
public class Cat extends Animal{
    public int weight;
    private int age;
}
public class ClassTest {
    public static void main(String[] args) throws NoSuchFieldException {
        Class cls = Cat.class;
        Field name = cls.getField("name");
        System.out.println(name);
        Field[] fields = cls.getDeclaredFields();
        Stream.of(fields).forEach(System.out::println);
    }
}
```

运行结果如下：

```bash
public java.lang.String ClassTest.Animal.name
public int ClassTest.Cat.weight
private int ClassTest.Cat.age
```

### Field 对象

上面的方法返回了一些Field对象，一个Field对象包含了一个字段的所有信息：

* getName()：返回字段名称，例如，"name"；
* getType()：返回字段类型，也是一个Class实例，例如，String.class；
* getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。

既然我们获取了Field对象，那能否获取Field对象里面的值呢？当然可以，我们可以使用Field对象的`get`方法就可以获取。

例如：
```java
Cat cat = new Cat();
cat.name = "wangcai";
Class cls = cat.getClass();
Field name = cls.getField("name");
System.out.println(name.get(cat));// wangcai
```

那么是否可以设置此字段呢？能获取自然就能设置嘛！可以通过Field对象的`set`方法来设置：

设置字段值是通过`Field.set(Object, Object)`实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值.

例如：
```java
Cat cat = new Cat();
cat.name = "wangcai";
Class cls = cat.getClass();
Field name = cls.getField("name");
System.out.println(name.get(cat));// wangcai
name.set(cat, "huahua");
System.out.println(name.get(cat));// huahua
```

## 访问方法






