# Java 注解(Annotation)

![java-annotations](https://tva1.sinaimg.cn/large/008eGmZEly1gp82orwxboj30sg0hsqb0.jpg)

前面我们学习了注释，使用`//`或者`/**/`来表示一段代码，一个类或者一个方法的作用，主要是方便人来快速的阅读代码而提供的解释性说明，也就是给人看的，这种代码一般会被编译器直接忽略，因为机器是看不懂给人写的注释。那如何让机器看懂我们写的注释呢？那么今天我们要学习的`注解(annotations)`就可以做到！

## 什么是注解？

> Java annotations are a mechanism for adding metadata information to our source code. They are a powerful part of Java, and were added in JDK5. Annotations offer an alternative to the use of XML descriptors and marker interfaces.

注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”, 是一种将元数据信息添加到我们的源代码中的机制。不同与注释，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。

### 注解的意义

基本上，注释会将额外的元数据分配给它绑定到的源代码。 通过向方法，接口，类或字段添加注释，我们可以利用注释来实现一下功能：
* 通知编译器警告和错误
* 在编译时处理源代码
* 在运行时修改或检查行为

## 注解的分类

从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。Java的注解可以分为三类：

### Java内置注解

这些注释会生成或禁止编译器警告和错误。 始终应用它们通常是一个好习惯，因为添加它们可以防止将来的程序员错误。这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了， 常见的有如下几种：

|Annotations| Description|
|-----------|------------|
|@Override|used to indicate that a method overrides or replaces the behavior of an inherited method.|
|@SuppressWarnings |indicates we want to ignore certain warnings from a part of the code.|
|@Deprecated|can be used to mark an API as not intended for use anymore. Moreover, this annotation has been retrofitted in Java 9 to represent more information about the deprecation.|
|@SafeVarargs|acts on a type of warning related to using varargs.|
|@FunctionalInterface|Java8之后提供给我们标注一个接口为函数式接口|
|@Native|only applicable to fields. It indicates the annotated field is a constant that may be referenced from the native code. |

### 工具类注解

是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。

### 运行期注解

是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。

这种注解我们程序中应用最多，我们可以自定义注解来实现，后面课程我们将着重介绍！

## 元注解

有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。

### @Target

最常用的元注解是@Target。使用@Target可以定义注解能够被应用于源码的哪些位置：

* 类或接口：ElementType.TYPE；
* 字段：ElementType.FIELD；
* 方法：ElementType.METHOD；
* 构造方法：ElementType.CONSTRUCTOR；
* 方法参数：ElementType.PARAMETER。

例如我们定一个注解：

```java
@Target({
    ElementType.METHOD,
    ElementType.FIELD
})
public @interface Validation {
    int type() default 0;
    int max() default 100;
}
```

表示该注解可以用于方法和属性上面。

### @Retention

另一个重要的元注解@Retention定义了Annotation的生命周期：

* 仅编译期：RetentionPolicy.SOURCE；
* 仅class文件：RetentionPolicy.CLASS；
* 运行期：RetentionPolicy.RUNTIME。

如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解：

例如我们定一个注解：

```java
@Target({
    ElementType.METHOD,
    ElementType.FIELD
})
@Retention(RetentionPolicy.RUNTIME)
public @interface Validation {
    int type() default 0;
    int max() default 100;
}
```

### @Inherited

使用`@Inherited`定义子类是否可继承父类定义的Annotation。`@Inherited`仅针对`@Target(ElementType.TYPE)`类型的annotation有效，即仅针对class的继承，对interface的继承无效：

```java
@Inherited
@Target({
    ElementType.METHOD,
    ElementType.FIELD
})
@Retention(RetentionPolicy.RUNTIME)
public @interface Validation {
    int type() default 0;
    int max() default 100;
}
```

## 自定义注解








