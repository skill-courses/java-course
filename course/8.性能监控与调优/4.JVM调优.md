# JVM调优

![jvm-optimizing](https://tva1.sinaimg.cn/large/008i3skNgy1gqrl2t9mn6j30dw080wew.jpg)

前面我们学习了Java内存模型和一些常用的监控工具，学习这些的目的主要是对JVM进行调优。讲真，JVM调优其实并不常见，JVM本身已经足够完善，可调整的范围不大，无非是一些常用的参数，但JVM调优又是一个繁琐的过程，需要不断的测试，调整，验证才能得出最佳的调优策略。本节我们将重点来了解JVM调优的目标和常见策略。

## 调什么？

***JVM调优听起来很高大上，但是要认识到，JVM调优应该是Java性能优化的最后一颗子弹。***

要认识到JVM调优不是常规手段，性能问题一般第一选择是优化程序，然后需要看看数据库层(SQL，连接池)是否有优化的地方，接着再分析框架层是否有性能制约的地方，最后的选择才是进行JVM调优。 JVM的自动内存管理本来就是为了将开发人员从内存管理的泥潭里拉出来。即使不得不进行JVM调优，也绝对不能拍脑门就去调整参数，一定要全面监控，详细分析性能数据。 

在不得不考虑进行JVM调优的是那些情况呢？系统吞吐量与响应性能不高或下降。 吞吐量、延迟、内存占用三者类似CAP，构成了一个不可能三角，只能选择其中两个进行调优，不可三者兼得。 选择了其中两个，必然会会以牺牲另一个为代价。 注意：不同应用的JVM调优量化目标是不一样的。

目前，我们能调整JVM的地方主要有两个：内存方面和线程方面。今天我们就内存调优来做个详细介绍！

## 内存调优

关于内存调优主要关注下面的几个方面：

* **JVM需要的内存总大小**

确定JVM的总大小至关重要，如果内存设置过大，会造成内存浪费，如果设置过小，内存不够用，会导致频繁的GC，降低系统的吞吐量。

* **调整内存区域大小比率**

设置了JVM总体的大小之后，需要调整各个内存的分配比率：新生代，老年代和存活区。如果对应区域空间不足，导致需要频繁GC来释放空间，在JVM堆内存无法增加的情况下，可以调整对应区域的大小比率。

* **选择合适的垃圾回收算法**

毫无疑问，选择合适的垃圾收集器非常有利于控制GC停顿次数和时间，例如：
    
    - CPU单核，那么毫无疑问Serial 垃圾收集器是你唯一的选择。
    - CPU多核，关注吞吐量 ，那么选择PS+PO组合。
    - CPU多核，关注用户停顿时间，JDK版本1.6或者1.7，那么选择CMS。
    - CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上，那么选择G1。

* **辅助代码优化**

我们可以查看内存走势，确定是否存在内存泄漏，从而为进一步定位问题代码提供参考方向。也可以通过热点检查，检查那些对象在系统中数量最大，通过这些提示信息，我们可以进行分析，进而辅助代码优化。

## 怎么调？

内存调优并没有一个固定的方案，但是有个大体一致的套路，我们可以按照这个套路所描述的步骤来调优：

1. 监控JVM运行状态，其中主要关注内存，线程，代码和I/O这几个部分
2. 分析系统系统运行情况主要包括分析GC日志及dump文件，判断是否需要优化，进而确定瓶颈问题点
3. 确定JVM调优量化指标和参数，其中包括内存大小，延迟，通途量等指标
4. 调整垃圾回收算法和内存分配比例，同时修改并优化代码。
5. 对比观察调优前后的差异，不断的重复监控，分析和调整，直至找到优化的平衡点。

## 调优的目标

* GC的时间要足够的小：单次GC的时间要少，不然每次GC会引起的停顿时间较长，再者就是所有GC的时间要小，从宏观上来说，我们希望我们的应用程序大量的时间应该在处理业务逻辑而不是处理GC。
* GC的次数要足够小：虽然单次GC的时间少，但是如果次数足够多，那么总体的GC时间也会边长，这也是不利的。
* 将转移到老年代的对象数量降低到最小：老年代中存活了时间较长，内存占用较大的对象，所以，理想情况下，最好在新生代将这些对象进行回收，最好不让过多的进入老年代。
* 减少FullGC的时间：我们知道每次FullGC会占用较长的时间，同时伴随着较长时间的停顿，这对应用程序相当的不友好，进来减少FullGC的时间。
* 发生FullGC的间隔足够长：由于FullGC占用较长的时间，那么间隔较长执行一次就比较理想。

## 调优的常用方法

* 减少创建对象的数量
* 减少使用全局变量和大对象
* 调整新生代、老年代的大小到最合适
* 选择合适的垃圾收集器，并设置合理的参数

## JVM调优冷思考

1. 多数Java应用不需要在服务器上面进行GC优化。
2. 多数导致GC问题的Java应用，都不是因为参数设置错误，而是代码问题。
3. 在应用上线之前，先考虑将机器的JVM参数设置到最优(最合适)。
4. JVM调优应该是Java性能优化的最后一颗子弹。
5. 在实际使用情况下，分析JVM情况来优化代码比优化JVM本身要多得多。




