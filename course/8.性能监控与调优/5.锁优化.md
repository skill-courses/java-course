# 锁优化

![lock](https://tva1.sinaimg.cn/large/008i3skNgy1gqs9despp0j31c00u0jwy.jpg)

高效并发是从JDK5升级到JDK6之后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术，如自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效的共享数据及解决竞争问题，从而提高程序的执行效率。

## 自旋锁与自适应自旋

![adaptive-lock](https://tva1.sinaimg.cn/large/008i3skNgy1gqsr5nsgf6j30go08cgm4.jpg)

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这点时间去挂起和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多核处理系统，能让两个或两个以上的线程同时并行执行，我们就可以让后面的请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。

为了让线程等待，我们只需要让线程执行一个忙循环(称之为自旋)，这项技术就是所谓的自旋锁。

自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但是它要占用处理器的时间，所以，如果自旋锁被占用的时间很短，自旋等待的效果就非常好，反之，如果锁被占用的时间很长，那么自旋的线程就会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定次数任然没有成功获得锁，就应当使用传统的方式挂起线程。自旋的次数默认值是十次，用户也可以使用参数`-XX:PreBlockSpin`来自行更改。

JDK6对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上自旋的时间及所得拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能成功，进而允许自旋等待更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得锁，那么在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。

有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了。

## 锁消除

***锁消除是指虚拟机及时编译器在运行时检测到某段需要同步的代码根本不可能存在共享数据的竞争而实施的一种对锁进行消除的优化策略。***

锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当做栈上的数据对待，认为他们是线程私有的，同步加锁自然就无须再进行。

## 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步代码块的作用范围限制的尽量小，只有在共享数据的实际作用域中才能进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快的拿到锁。

大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体之中的，那么即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。

如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁的同步的范围扩展到整个操作序列的外部，这样就只需要加锁一次就可以了。

## 轻量级锁

轻量级锁是JDK6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言，因此传统的锁机制就被称为“重量级”锁。不过，需要强调一点，轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

轻量级锁能提升程序同步性能的依据是“对于对大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁边通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此，在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。

## 偏向锁

偏向锁也是JDK6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁实在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。

偏向锁中的“偏”，就是偏心的“偏”，偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一致没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。

偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效率的权衡性质的优化，也就是说它并非总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的提前下，有时候使用参数`-XX:-UseBiasedLocking`来禁止偏向锁优化反而可以提升性能。
