# 锁优化

![lock](https://tva1.sinaimg.cn/large/008i3skNgy1gqs9despp0j31c00u0jwy.jpg)

高效并发是从JDK5升级到JDK6之后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术，如自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等，这些技术都是为了在线程之间更高效的共享数据及解决竞争问题，从而提高程序的执行效率。

## 自旋锁与自适应自旋

![adaptive-lock](https://tva1.sinaimg.cn/large/008i3skNgy1gqsr5nsgf6j30go08cgm4.jpg)

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这点时间去挂起和恢复线程并不值得。现在绝大多数的个人电脑和服务器都是多核处理系统，能让两个或两个以上的线程同时并行执行，我们就可以让后面的请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。

为了让线程等待，我们只需要让线程执行一个忙循环(称之为自旋)，这项技术就是所谓的自旋锁。

自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但是它要占用处理器的时间，所以，如果自旋锁被占用的时间很短，自旋等待的效果就非常好，反之，如果锁被占用的时间很长，那么自旋的线程就会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定次数任然没有成功获得锁，就应当使用传统的方式挂起线程。自旋的次数默认值是十次，用户也可以使用参数`-XX:PreBlockSpin`来自行更改。

JDK6对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上自旋的时间及所得拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能成功，进而允许自旋等待更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得锁，那么在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。

有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了。

## 锁消除

***锁消除是指虚拟机及时编译器在运行时检测到某段需要同步的代码根本不可能存在共享数据的竞争而实施的一种对锁进行消除的优化策略。***

锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把他们当做栈上的数据对待，认为他们是线程私有的，同步加锁自然就无须再进行。

## 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步代码块的作用范围限制的尽量小，只有在共享数据的实际作用域中才能进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快的拿到锁。

大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体之中的，那么即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。

如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁的同步的范围扩展到整个操作序列的外部，这样就只需要加锁一次就可以了。




