# Java内存模型

![model-of-memory](https://i.loli.net/2021/05/19/qDQepMjCIZ5mrOG.png)

《Java虚拟机规范中》定义了一种“Java内存模型”来屏蔽各种硬件和操作系统的内存访问差异，此内存模型经过长时间的验证和修补，知道JDK5发布之后，才终于成熟，完善起来！

定义“Java内存模型”的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。

## 主内存与工作内存

Java内存模型规定了所有的变量都存储在主内存中，同时，每条线程还有自己的工作内存，线程的工作内存保存了被该线程使用的变量的主内存副本，线程对所有变量的操作(读写)都必须在工作内存中进行，而不能直接读写主内存中的数据。

不同线程之间无法直接访问对方内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程，主内存与工作内存三者之间的关系如图所示：

![java-memory-thread](https://i.loli.net/2021/05/19/s9PMqglGiTIrLh3.png)

### 内存间交互操作

Java内存模型中定义了以下8中操作来完成交互，JVM必须保证下面提到的每一种操作都是原子的，不可再分的：

* Lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* Unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* Read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
* Load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
* Use(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用的变量的值的字节指令时将会执行这个操作。
* Assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接受到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* Store(存储)：作用于工作内存的变量，它把工作内存中的变量值传递给主内存，以便随后的write操作使用。
* Write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

### 8中指令的执行规则

为了使得上面的八种操作执行合理有序的执行，Java内存模型还规定了这几种基本操作必须要满足的如下规则：

* 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取达到工作内存中不接受，或者工作内存发起了会写但出内存不接受的情况出现。
* 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把改变化同步会主内存。
* 不允许一个线程无原因的把数据从线程的工作内存同步到主内存中。
* 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未初始化的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assgin和load操作。
* 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。
* 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量之前，需要重新执行load或assign操作以初始化变量的值。
* 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
* 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中去。

## Volatile型变量的特殊规则

关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，当一个变量被定义成volatile之后，它将具备两项特性：

### 1. 线程可见性

当一个变量被volatile修饰之后，就能保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通的变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。

比如线程A修改了一个普通的变量的值，然后向主内存进行会写，另外一条线程B在线程A会写之后再对主内存进行读取操作，新变量值才会对线程B可见。

关于volatile变量的可见性，经常会被开发人员误解：“volatile变量对所有线程是立即可见的，对volition变量所有的写操作都能立刻反应到其他线程中去。换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的。” 这句话的论据部分没有错误，但是不能得出“以基于volatile变量的运算在并发下是线程安全的”这样的结论，关键点原因是，Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的，下面的例子可以证明：



