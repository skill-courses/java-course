# Java内存模型

![model-of-memory](https://i.loli.net/2021/05/19/qDQepMjCIZ5mrOG.png)

《Java虚拟机规范中》定义了一种“Java内存模型”来屏蔽各种硬件和操作系统的内存访问差异，此内存模型经过长时间的验证和修补，知道JDK5发布之后，才终于成熟，完善起来！

定义“Java内存模型”的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。

## 主内存与工作内存

Java内存模型规定了所有的变量都存储在主内存中，同时，每条线程还有自己的工作内存，线程的工作内存保存了被该线程使用的变量的主内存副本，线程对所有变量的操作(读写)都必须在工作内存中进行，而不能直接读写主内存中的数据。

不同线程之间无法直接访问对方内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程，主内存与工作内存三者之间的关系如图所示：

![java-memory-thread](https://i.loli.net/2021/05/19/s9PMqglGiTIrLh3.png)

### 内存间交互操作

Java内存模型中定义了以下8中操作来完成交互，JVM必须保证下面提到的每一种操作都是原子的，不可再分的：

* Lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* Unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* Read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
* Load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
* Use(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用的变量的值的字节指令时将会执行这个操作。
* Assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接受到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* Store(存储)：作用于工作内存的变量，它把工作内存中的变量值传递给主内存，以便随后的write操作使用。
* Write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

### 8中指令的执行规则

为了使得上面的八种操作执行合理有序的执行，Java内存模型还规定了这几种基本操作必须要满足的如下规则：

* 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取达到工作内存中不接受，或者工作内存发起了会写但出内存不接受的情况出现。
* 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把改变化同步会主内存。
* 不允许一个线程无原因的把数据从线程的工作内存同步到主内存中。
* 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未初始化的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assgin和load操作。
* 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。
* 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量之前，需要重新执行load或assign操作以初始化变量的值。
* 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
* 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中去。

## Volatile型变量的特殊规则

关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，当一个变量被定义成volatile之后，它将具备两项特性：

### 1. 线程可见性

当一个变量被volatile修饰之后，就能保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通的变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。

比如线程A修改了一个普通的变量的值，然后向主内存进行回写，另外一条线程B在线程A回写之后再对主内存进行读取操作，新变量值才会对线程B可见。

关于volatile变量的可见性，经常会被开发人员误解：“volatile变量对所有线程是立即可见的，对volition变量所有的读写操作都能立刻反应到其他线程中去。换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的。” 这句话的论据部分没有错误，但是不能得出“以基于volatile变量的运算在并发下是线程安全的”这样的结论，关键点原因是，Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的，下面的例子可以证明：

```java
public class Volatile {
    public static volatile int count = 0;
    
    public static void add() {
        count++;
    }
    
    public static void decrease() {
        count--;
    }
}

public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++) {
                    Volatile.add();
                }
            }
        });
    
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++) {
                    Volatile.decrease();
                }
            }
        });
        thread1.start();
        thread2.start();
    
        System.out.println(Volatile.count);
    }
}
```

上面的代码运行结果是0么？多次运行发现，并不是，大多在0~10000之间的某个数字，这就说明上面的代码并不是线程安全的，到底是怎么回事呢？

问题就在`count++`和`count--`这个两条语句上，这两条语句中每条语句都是由四条字节码指令构成，所以这些指令合成去操作变量并发是原子性的，导致了这个值并不是期望的结果。

由于volatile变量只能保证可见性，对于以下两种情况，我们只能使用锁来实现原子性：

1. 运算结果并不依赖当前值，或者能够确保只有单一的线程修改变量的值。
2. 变量不需要与其他的状态变量共同参与不变约束。

### 禁止指令重排序优化

普通的变量仅会保证在该方法的执行过程中所有的依赖赋值结果的地方都能获取正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这个点，这就是Java内存模型中描述的所谓“线程内表现为串行的语义”。

那为何要禁止指令重排序呢？从硬件架构上讲起，指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。但并不是说指令任意重排序，处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果。

譬如，指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去5，这时，指令1和指令2是有依赖的，他们的顺序是不能重排的，但指令3可以重排到指令1和指令2之前或者中间，只要保证处理器执行后面依赖到A，B值的操作时能正确获取到A和B的值即可。所以，在同一个处理器中，重排序过的代码看起来依然是有序的。

在某些情况下，volatile的同步机制的性能确实要优于锁，但是由于虚拟机对锁实行的许多消除和优化，使得我们很难准确的锁volatile就会比synchronized快上多少。不过，即便如此，大多数场景下volatile的总开销仍然要比锁来的更低。

## 原子性、可见性和有序性
java内存模型是围绕着在并发过程中如何处理原子性，可见性和有序性这三个特性来建立的，我们逐个来看一下哪些操作实现了这三个特性。

### 1. 原子性

Java内存模型直接保证原子性变量的操作包括`read`,`load`,`assign`,`use`,`store`,`write`这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的。

如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，这两个字节码反映到Java代码中就是同步块----synchronized关键字，因此，在synchronized块之间的操作也具备原子性。

### 可见性

可见性就是指当一个线程修改了贡献变量的值时，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。无论是普通变量还是volatile变量都是如此。

普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能够立即同步到主内存，以及每次使用前立即从主内存刷新。因此，我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。

### 有序性

Java内存模型的有序性在前面讲解volatile时也比较详细的讨论过了，可以总结为一句话：如果在线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

Java语言提供了volatile和synchronized两个关键字来实现线程之间的有序性。


